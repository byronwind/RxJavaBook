# 第 1 章 使用 RxJava 进行响应式编程

RxJava 是 Java 和 Android 平台上响应式编程的一种具体实现，它受到函数式编程的影响。RxJava 支持函数组合，避免了全局变量和副作用，通过流式的思维构建异步和基于事件的程序。它从生产者消费者回调的观察者模式开始，扩展了几十种允许组合、变换、调度、节流、错误处理和生命周期管理的操作符。

RxJava 是一个成熟的开源库，已在服务器和 Android 移动设备上广泛采用。伴随这个类库，一个活跃的开发者社区已经建立起来，社区围绕 RxJava 和响应式编程，贡献项目、演讲和文档，互帮互助。

本章将会对 RxJava 做一个概览——RxJava 是什么，它是如何工作的——本书其余部分会带读者了解如何在自己的应用程序中使用 RxJava 的所有细节。你可以在没有任何响应式编程经验的前提下阅读本书，但我们会在一开始就将介绍 RxJava 的概念和实践，以便你可以将其优势应用到自己的用例中。


## 响应式编程和 RxJava

响应式编程（Reactive programming）是一个通用的编程术语。它关注于对诸如数据值或者事件等变化做出响应。它可以并且经常是强制命令性的执行。回调（callback）是一种强制命令式执行响应式编程的一种方法。电子表格是一个很好的响应式编程的例子：依赖于其他单元格的单元格在那些被依赖的单元格发生变化时，会自动做出响应。

今天的计算机，在某种程度上，一切都是通过命中操作系统和硬件来执行命令。我们必须明确告诉计算机需要做什么和怎么做。人类不会像CPU或者相关系统一样思考，所以我们增加了抽象。响应式函数编程是一种抽象，就像是我们的高级命令式编程语言是对底层二进制和汇编指令的抽象。事实上，一切最终必须被记住和理解是很重要的，因为它帮助我们了解响应式函数编程寻址和最终如何执行的心智模型——这里没有魔法。

响应函数式编程是一种编程方法——一种命令式系统之上的抽象——它允许我们对异步和事件驱动的用例编程，而不必像计算机本身一样思考，并且强制定义状态的复杂交互，特别是在跨线程和跨网络边界的情况下。当涉及到异步和事件驱动系统时，不必像计算机思考是一项有用的特质。因为涉及并发和并行性，正确和高效的使用这些特性，是非常有挑战的事情。在Java 社区中，由 Brian Goetz 编著的《Java 并发编程实践》和由 Doug Lea 编著的《Java 并发编程》(Addison-Wesley 出版版本) 两本书，以及诸如『Mechanical Sympathy』的论坛是掌握并发的深度、广度和复杂度的代表。从我使用 RxJava 以来，我与这些书籍作者、论坛和社区专家的交流，使我比之前更加深刻的意识到编写高性能、高效、可扩展和正确的并发软件是多么困难。我们甚至还没有引入分布式系统，它使并发和并行性达到了另外一个层次。

所以，对于『响应式函数编程解决的是什么问题』这个问题，简单的回答就是并发和并行性。更通俗的讲，它用命令方式处理响应和异步的用例，解决『回调地狱』问题。诸如 RxJava 实现的响应式编程受到函数式编程的影响，并且使用声明式方法来避免响应式命令性代码的典型缺陷。

## 何时需要响应式编程

在诸如以下的场景中，响应式编程是非常有用的：

- 处理用户事件，例如：鼠标移动和点击、键盘输入、用户移动设备时，GPS 信号随时间变化、设备的陀螺仪信号变化、触摸事件等等。

- 响应和处理所有源自磁盘和网络的延迟绑定 IO 事件（IO 本质上是异步的，发出一个请求，一段时间后收到或者收不到响应，然后再触发后续的工作）。

- 处理由应用程序推送的无法由应用控制的事件或者数据（来自服务器的系统事件、前述的用户事件、硬件信号、来自传感器模拟信号触发的事件等等）。

如果问题中的代码只处理一个事件流，使用带回调的命令式响应编程就很好，并且引入函数式响应编程并不会给你带来太多好处。你可以有数百种不同的事件流，如果他们彼此完全独立，命令式编程可能不是个问题。在这种简单明了的用例下，命令式的编程方法是最有效的，因为它们消除了响应式编程的抽象层，并且更接近当前操作系统、语言和编译器优化的层次。

如果你的程序像大多数一样，需要组合事件（或来自函数或者网络调用的异步响应），有它们之间的条件逻辑交互，并且必须处理所有这些事件的失败场景和资源清理。这就是命令式响应编程的复杂度开始显著提高和函数式响应编程大放异彩的地方。我开始接受的一个非科学的观点是，函数式响应编程有一个初始较高的学习曲线和入门的障碍，但是复杂性的上限却远低于命令式响应编程。

因此，这就是响应式扩展（Rx）和 RxJava 的口号的具体出处：『一个用于异步和基于事件的程序库』。RxJava 是一种受函数式和数据流编程的影响的响应式编程原理的具体实现。有许多种不同的方法实现响应性，RxJava 只是其中之一。让我们深入了解它是如何工作的。

## RxJava 如何工作

RxJava 的中心是表现数据流或事件流的可观测类型。它可以用于推（响应式）的场景，但也可以用于拉（交互式）的场景。它是懒惰的而不是渴望的。 它可以异步或同步使用。 可以表示时间上的0、1、许多或无限大的值或事件。

这里有很多流行用语和细节，让我们逐步了解它们。你可以在27页的『剖析 Rx Observable』中得到完整的细节。

### 推和拉的比较

RxJava 响应式的整个点是支持推送。因此，被观察者和相关的观察者类型签名支持事件被推送给它。这反过来通常会伴随异步，下一节将会讨论到这一点。但是可观察类型也支持一个异步反馈通道（有时也成为异步拉取或响应式拉取），作为异步系统中的流控制或者背压的方法。本章的后面部分将会讨论流控制以及这种机制的适应性。

为了支持通过推送接收事件，一对被观察者/观察者（Observable/Observer）通过订阅联系在一起。被观察者（Observable）表示数据流，可以由 Observer 订阅（您将会在第32页的『使用 Observer<T> 捕获所有通知』中了解更多信息）：


    interface Observable<T> {
        Subscription subscribe(Observer s)
    }


订阅时，观察者可以有三种不同类型的事件推送给它：

- 数据通过 `onNext()` 函数接收
- 错误（Exception 或者 Throwable）通过`onError()` 函数接收
- 事件流通过`onCompleted()`函数结束

```
    interface Observer<T> {
        void onNext(T t)
        void onError(Throwable t) void onCompleted()
    }
```

`onNext()` 方法可能不会被调用，也可能被调用一次、多次或者无限次。`onError()`和`onCompleted()`方法是结束事件，也就是二者之中只能有一个被调用且只会被调用一次。当一个结束事件被调用时，被观察的流即结束，也不会再有更多的事件通过它发送。如果事件流是无限的，同时也没有错误发生，结束事件就不会触发。

